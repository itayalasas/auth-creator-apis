/* Auto-generated by AuthSystem - 2025-10-27T04:41:26.727Z */
/**
 * Security Validation and Sanitization Utilities
 * Protects against XSS, SQL Injection, and other attacks
 */

// Email validation - RFC 5322 compliant
const EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&'*+/=?^_\`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;

// Password strength requirements
export interface PasswordValidation {
  valid: boolean;
  errors: string[];
  strength: 'weak' | 'medium' | 'strong' | 'very-strong';
}

/**
 * Validates email format
 */
export function validateEmail(email: string): { valid: boolean; error?: string } {
  if (!email || typeof email !== 'string') {
    return { valid: false, error: 'Email es requerido' };
  }

  const trimmed = email.trim();

  if (trimmed.length === 0) {
    return { valid: false, error: 'Email no puede estar vacío' };
  }

  if (trimmed.length > 254) {
    return { valid: false, error: 'Email demasiado largo' };
  }

  if (!EMAIL_REGEX.test(trimmed)) {
    return { valid: false, error: 'Formato de email inválido' };
  }

  return { valid: true };
}

/**
 * Validates password strength
 */
export function validatePassword(password: string): PasswordValidation {
  const errors: string[] = [];
  let strength: PasswordValidation['strength'] = 'weak';

  if (!password || typeof password !== 'string') {
    return {
      valid: false,
      errors: ['Contraseña es requerida'],
      strength: 'weak'
    };
  }

  // Minimum length
  if (password.length < 8) {
    errors.push('Mínimo 8 caracteres');
  }

  // Maximum length (prevent DoS)
  if (password.length > 128) {
    errors.push('Máximo 128 caracteres');
  }

  // At least one uppercase letter
  if (!/[A-Z]/.test(password)) {
    errors.push('Al menos una letra mayúscula');
  }

  // At least one lowercase letter
  if (!/[a-z]/.test(password)) {
    errors.push('Al menos una letra minúscula');
  }

  // At least one number
  if (!/[0-9]/.test(password)) {
    errors.push('Al menos un número');
  }

  // At least one special character
  if (!/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
    errors.push('Al menos un carácter especial (!@#$%^&*...)');
  }

  // Calculate strength
  let strengthScore = 0;
  if (password.length >= 8) strengthScore++;
  if (password.length >= 12) strengthScore++;
  if (/[A-Z]/.test(password)) strengthScore++;
  if (/[a-z]/.test(password)) strengthScore++;
  if (/[0-9]/.test(password)) strengthScore++;
  if (/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) strengthScore++;
  if (password.length >= 16) strengthScore++;

  if (strengthScore <= 3) strength = 'weak';
  else if (strengthScore <= 5) strength = 'medium';
  else if (strengthScore <= 6) strength = 'strong';
  else strength = 'very-strong';

  return {
    valid: errors.length === 0,
    errors,
    strength
  };
}

/**
 * Sanitizes string input to prevent XSS
 */
export function sanitizeInput(input: string, maxLength: number = 255): string {
  if (!input || typeof input !== 'string') {
    return '';
  }

  return input
    .trim()
    // Remove dangerous characters
    .replace(/[<>'"]/g, '')
    // Remove null bytes
    .replace(/\0/g, '')
    // Limit length
    .substring(0, maxLength);
}

/**
 * Sanitizes name (allows letters, spaces, hyphens, apostrophes)
 */
export function sanitizeName(name: string): string {
  if (!name || typeof name !== 'string') {
    return '';
  }

  return name
    .trim()
    // Only allow letters, spaces, hyphens, apostrophes
    .replace(/[^a-zA-ZáéíóúÁÉÍÓÚñÑ\s\-']/g, '')
    // Remove multiple spaces
    .replace(/\s+/g, ' ')
    .substring(0, 100);
}

/**
 * Validates and sanitizes all auth form data
 */
export interface AuthFormData {
  email?: string;
  password?: string;
  confirmPassword?: string;
  name?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: { [key: string]: string };
  sanitized: AuthFormData;
}

export function validateAuthForm(
  data: AuthFormData,
  formType: 'login' | 'register' | 'reset-password'
): ValidationResult {
  const errors: { [key: string]: string } = {};
  const sanitized: AuthFormData = {};

  // Email validation (required for all forms)
  if (data.email) {
    const emailValidation = validateEmail(data.email);
    if (!emailValidation.valid) {
      errors.email = emailValidation.error || 'Email inválido';
    } else {
      sanitized.email = sanitizeInput(data.email.toLowerCase(), 254);
    }
  } else {
    errors.email = 'Email es requerido';
  }

  // Password validation (required for login and register)
  if (formType !== 'reset-password') {
    if (data.password) {
      // Only validate password strength for registration
      // For login, just check it's not empty
      if (formType === 'register') {
        const passwordValidation = validatePassword(data.password);
        if (!passwordValidation.valid) {
          errors.password = passwordValidation.errors.join(', ');
        } else {
          // Don't sanitize password - use as-is
          sanitized.password = data.password;
        }
      } else {
        // Login: accept any password, server will verify
        sanitized.password = data.password;
      }
    } else {
      errors.password = 'Contraseña es requerida';
    }
  }

  // Name validation (required for register)
  if (formType === 'register') {
    if (data.name) {
      const sanitizedName = sanitizeName(data.name);
      if (sanitizedName.length < 2) {
        errors.name = 'Nombre debe tener al menos 2 caracteres';
      } else if (sanitizedName.length > 100) {
        errors.name = 'Nombre demasiado largo';
      } else {
        sanitized.name = sanitizedName;
      }
    } else {
      errors.name = 'Nombre es requerido';
    }

    // Confirm password validation
    if (data.confirmPassword) {
      if (data.password !== data.confirmPassword) {
        errors.confirmPassword = 'Las contraseñas no coinciden';
      } else {
        sanitized.confirmPassword = data.confirmPassword;
      }
    } else {
      errors.confirmPassword = 'Confirmar contraseña es requerido';
    }
  }

  return {
    valid: Object.keys(errors).length === 0,
    errors,
    sanitized
  };
}

/**
 * Checks for common weak passwords
 */
const COMMON_PASSWORDS = [
  '12345678', 'password', 'qwerty123', 'abc12345',
  'password123', '12345678', 'iloveyou', 'admin123'
];

export function isCommonPassword(password: string): boolean {
  const lower = password.toLowerCase();
  return COMMON_PASSWORDS.some(common => lower.includes(common));
}

/**
 * Rate limiting helper (client-side check)
 */
export class ClientRateLimiter {
  private attempts: Map<string, number[]> = new Map();

  canAttempt(key: string, maxAttempts: number = 5, windowMs: number = 60000): boolean {
    const now = Date.now();
    const attempts = this.attempts.get(key) || [];

    // Remove old attempts outside the window
    const recentAttempts = attempts.filter(time => now - time < windowMs);

    // Check if limit exceeded
    if (recentAttempts.length >= maxAttempts) {
      return false;
    }

    // Add current attempt
    recentAttempts.push(now);
    this.attempts.set(key, recentAttempts);

    return true;
  }

  getRemainingAttempts(key: string, maxAttempts: number = 5, windowMs: number = 60000): number {
    const now = Date.now();
    const attempts = this.attempts.get(key) || [];
    const recentAttempts = attempts.filter(time => now - time < windowMs);
    return Math.max(0, maxAttempts - recentAttempts.length);
  }

  getTimeUntilReset(key: string, windowMs: number = 60000): number {
    const attempts = this.attempts.get(key) || [];
    if (attempts.length === 0) return 0;

    const oldestAttempt = Math.min(...attempts);
    const timeUntilReset = windowMs - (Date.now() - oldestAttempt);

    return Math.max(0, timeUntilReset);
  }

  reset(key: string): void {
    this.attempts.delete(key);
  }
}

// Export singleton instance
export const rateLimiter = new ClientRateLimiter();
